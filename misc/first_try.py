from dwave.system.samplers import DWaveSampler           
from dwave.system.composites import EmbeddingComposite   
import dwave.inspector
import json

'''
  this is the actual data, as a graph, being put on the qpu. This is generated by 
  iterating over a dataset and applying a QUBO function on the data.
'''

'''
  The objective is the variables w/ the coefficients. The coefficients are what the variables are set to.
  These are the nodes of the graph.
'''
objective = {(0,0): -2.0, (1,1): -2.0, (2,2): 1.0}

'''
  the constraints are the edges of the graph.
'''
constraints = {(0, 1): 2.0, (0, 2): -4.0, (1,2): -4.0}


'''
  combine the objective and constraints into a single dictionary, which is really a graph, to send to the qpu.
'''
qubo = {**objective, **constraints}

'''
  create a sampler, this is what actually solves the issue
'''
sampler = DWaveSampler(solver={"qpu":True})


'''
  create an embedding on the qpu automatically for the problem w/ the sampler. 
  The embedding composite tries to fit the problem on the qpu, which we get from creating a sampler
'''
response = EmbeddingComposite(sampler).sample_qubo(qubo, chain_strength=5, num_reads=100)

'''
  print the response, returns in a custom table
'''
print(response.info["problem_id"])

'''
  save as json
'''
with open("test.json", "w") as t_r:
    json.dump(response.to_serializable(), t_r) 


'''
  show the data embedded on the qpu.
'''
dwave.inspector.show(response)  